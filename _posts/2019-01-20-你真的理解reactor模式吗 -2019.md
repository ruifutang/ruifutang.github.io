---
layout:     post
title:      你真的理解reactor模式吗
subtitle:   Talk is cheap, just a demo
date:       2019-01-20
author:     唐瑞甫
header-img: img/post-bg-coffee.jpeg
catalog: true
tags: -reactor

---  

团队所采用的框架是用[Reactor模式](https://en.wikipedia.org/wiki/Reactor)实现的。正好借这个机会，聊下reactor模式。


> The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. Each service in an application may consist of serveral methods and is represented by a separate event handler that is responsible for dispatching service-specific requests. Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. Demultiplexing of service requests is performed by a synchronous event demultiplexer.
  
画个图就明白了。  

![Reactor_Flow](img/Reactor_Flow.png) 
  
在来看下reactor模式的整体架构图。

![Reactor_Flow](img/Reactor_Structures.png) 

那这些模块之间是如何进行交互的呢？用代码实现一遍就明白了。

```cpp
// reactor.h
#ifndef REACTOR_H_
#define REACTOR_H_

#include <memory>
#include <unistd.h>
#include <sys/epoll.h>

typedef unsigned int event_t;

typedef int handle_t;

enum EVENT_TYPE
{
    READ_EVENT    = 0x01,
    WRITE_EVENT   = 0x02,
    EVENT_END
};

class EventHandler
{
public:
    virtual handle_t GetHandle() const = 0;

    virtual void HandleRead() {}

    virtual void HandleWrite() {}

protected:

    EventHandler() {}

    virtual ~EventHandler() {}
};

class ReactorImplementation;

class Reactor
{
public:

    Reactor();

    ~Reactor();

    int RegisterHandler(EventHandler * handler, event_t event);

    int RemoveHandler(EventHandler * handler);

    void HandleEvents();

private:
    std::shared_ptr<ReactorImplementation> m_reactor_impl;
};

#endif // REACTOR_REACTOR_H_
```
为了简单起见，只定义了两种不同类型的事件，分别为read & write，再来看下对应的实现。

```cpp
#include "reactor.h"
#include "event_demultiplexer.h"

class ReactorImplementation
    {
public:

    ReactorImplementation();

    ~ReactorImplementation();

    int RegisterHandler(EventHandler* handler, event_t event);

    int RemoveHandler(EventHandler* handler);

    void HandleEvents();

private:

    std::shared_ptr<EventDemultiplexer>     m_demultiplexer;
    std::map<handle_t, EventHandler*>  m_handlers;

};


Reactor::Reactor()
{
    m_reactor_impl = std::make_shared<ReactorImplementation>();
}

Reactor::~Reactor()
{
}

int Reactor::RegisterHandler(EventHandler * handler, event_t event)
{
    return m_reactor_impl->RegisterHandler(handler, event);
}

int Reactor::RemoveHandler(EventHandler * handler)
{
    return m_reactor_impl->RemoveHandler(handler);
}

void Reactor::HandleEvents()
{
    m_reactor_impl->HandleEvents();
}

ReactorImplementation::ReactorImplementation()
{
    m_demultiplexer = std::make_shared<EpollEventDemultiplexer>();
}

ReactorImplementation::~ReactorImplementation()
{
}

int ReactorImplementation::RegisterHandler(EventHandler * handler, event_t event)
{
    handle_t handle = handler->GetHandle();
    std::map<handle_t, EventHandler *>::iterator it = m_handlers.find(handle);
    if (it == m_handlers.end())
    {
        m_handlers[handle] = handler;
    }
    return m_demultiplexer->RequestEvent(handle, event);
}

int ReactorImplementation::RemoveHandler(EventHandler * handler)
{
    handle_t handle = handler->GetHandle();
    m_handlers.erase(handle);
    return m_demultiplexer->UnrequestEvent(handle);
}

void ReactorImplementation::HandleEvents()
{
    m_demultiplexer->WaitEvents(&m_handlers);
}

```
这里最核心的就是RegisterHandler这个方法，只有先注册了后面才能回调，这个方法是在EventDemultiplexer这个类中定义的，来看下EventDemultiplexer这个类  

```cpp
#ifndef REACTOR_EVENT_DEMULTIPLEXER_H_
#define REACTOR_EVENT_DEMULTIPLEXER_H_

#include <memory>
#include <set>
#include <map>
#include "reactor.h"

class EventDemultiplexer
{
public:

    virtual ~EventDemultiplexer() {}

    virtual int WaitEvents(std::map<handle_t, EventHandler*>* handlers) = 0;

    virtual int RequestEvent(handle_t handle, event_t event) = 0;

    virtual int UnrequestEvent(handle_t handle) = 0;
};

class EpollEventDemultiplexer : public EventDemultiplexer
{
public:
    EpollEventDemultiplexer();

    ~EpollEventDemultiplexer();

    virtual int WaitEvents(std::map<handle_t, EventHandler *> * handlers);

    virtual int RequestEvent(handle_t handle, event_t event);

    virtual int UnrequestEvent(handle_t handle);

private:

    int  m_epoll_fd;
    int  m_fd_num;
};
#endif // REACTOR_EVENT_DEMULTIPLEXER_H_  
```
这里采用了epoll来进行IO多路复用，如果在macOS这种平台上操作或者要选用select()实现的话只要继承EventDemultiplexer这个虚基类就可以了，来看下对应的cc文件。

```cpp
#include <errno.h>
#include <vector>
#include "event_demultiplexer.h"

EpollEventDemultiplexer::EpollEventDemultiplexer()
{
    m_epoll_fd = epoll_create(FD_SETSIZE);
    m_fd_num = 0;
}

EpollEventDemultiplexer::~EpollEventDemultiplexer()
{
    close(m_epoll_fd);
}

int EpollEventDemultiplexer::WaitEvents(std::map<handle_t, EventHandler*> *handlers)
{
    std::vector<epoll_event> vec_events(m_fd_num);
    int num = epoll_wait(m_epoll_fd, &vec_events[0], vec_events.size(), -1);
    if (num > 0)
    {
        for (int i = 0; i < num; ++i)
        {
            handle_t handle = vec_events[i].data.fd;
            if ((vec_events[i].events & EPOLLERR) ||
                    (vec_events[i].events & EPOLLHUP))
            {
                return -1;
            }
            else
            {
                if (vec_events[i].events & EPOLLIN)
                {
                    (*handlers)[handle]->HandleRead();
                }
                if (vec_events[i].events & EPOLLOUT)
                {
                    (*handlers)[handle]->HandleWrite();
                }
            }
        }
    }

    return num;
}

int EpollEventDemultiplexer::RequestEvent(handle_t handle, event_t event)
{
    epoll_event ep_event;
    
    ep_event.data.fd = handle;
    ep_event.events = 0;

    if (event & READ_EVENT)
    {
        ep_event.events |= EPOLLIN;
    }
    if (event & WRITE_EVENT)
    {
        ep_event.events |= EPOLLOUT;
    }
    ep_event.events |= EPOLLONESHOT;

    if (epoll_ctl(m_epoll_fd, EPOLL_CTL_MOD, handle, &ep_event) != 0)
    {
        if (errno == ENOENT)
        {
            if (epoll_ctl(m_epoll_fd, EPOLL_CTL_ADD, handle, &ep_event) != 0)
            {
                return -errno;
            }
            ++m_fd_num;
        }
    }
    return 0;
}

int EpollEventDemultiplexer::UnrequestEvent(handle_t handle)
{
    epoll_event ep_event;
    if (epoll_ctl(m_epoll_fd, EPOLL_CTL_DEL, handle, &ep_event) != 0)
    {
        return -errno;
    }
    --m_fd_num;
    return 0;
}

```
  
在RequestEvent里面对于之前定义的read & write 事件进行注册，而在WaitEvents中对于到来的 read | write 事件进行处理。  
那么怎么进行处理呢？那就要依赖具体的业务逻辑了。

```cpp
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <arpa/inet.h>
#include <string>
#include "reactor.h"
#include "event_demultiplexer.h"

Reactor g_reactor;

class DemoServer : public EventHandler
{
public:
    DemoServer(handle_t handle) :
        EventHandler(),
        m_handle(handle)
    {}

    virtual handle_t GetHandle() const
    {
        return m_handle;
    }

    virtual void HandleRead()
    {
        //dealing read events
    }

    virtual void HandleRead()
    {
        //dealing write events
    }

private:
    handle_t m_handle;
};


int main()
{

    DemoServer server(READ_EVENT);
    g_reactor.RegisterHandler(&server, READ_EVENT);

    //your own business
    //TODO
    
    return 0;
}

```
你只需要专注于你的业务逻辑就可以了。  
关于reactor模式对于性能究竟有多大的提升，可以参考下[这篇文章](https://www.mdw.la/papers/seda-sosp01.pdf) ,额外多说一句，这边文章是发表在**SOSP**顶会上的paper，含金量是相当相当高的。

我个人对reactor的总结就两点: 

1. Synchronize IO
2. register & callback


---
  By 唐瑞甫
  2019-01-20

