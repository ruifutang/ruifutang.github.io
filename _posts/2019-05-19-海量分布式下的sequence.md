---
layout:     post
title:      IM服务如何保证消息不丢失(下) 
subtitle:   海量分布式环境中的sequence
date:       2019-05-26
author:     唐瑞甫
header-img: img/post-bg-coffee.jpeg
catalog: true
tags: 
    - 分布式

---  

上一篇文章介绍了微信的 sequence 的机制，sequence 采用了一种非常简洁优雅的方式实现了可靠的消息收发传达。从现实落地的角度来看，直接将 sequence 应用在微信如此高并发的场景中还是需要做一些优化的，毕竟每个用户都是独立的空间。所以在如此海量的访问中，要保证 seq_no 可靠递增不回退，依然是个不小的挑战。

### sequence 的挑战

  
对于 sequence 来讲，一个大的挑战来自持久化存储。比如最简单的两个人聊天的场景  
  
![seq1](https://wx1.sinaimg.cn/mw1024/9a30a1bagy1g3f62z9f33j20sg0lc0u6.jpg)
  
由于用户的 seq_no 都是独立储存，所以会涉及到多个 svr_seq 的更新。而对于整个微信来讲，每秒的对于 svr_seq 的访问可能是千万级的。
由于服务端会保存每个用户最大的 seq_no，所以每次更新完后都需要落地存储，但是按照目前这种级别的访问量来讲，几乎没有任何硬盘系统能直接扛得住。  
  
为了降低 IO 方面的负载，可以考虑一种步进式的设计方案。对于 sequence 的设计来讲，其实最核心的是必须要递增，而不一定非得连续。这样我们就可以不用每次更新完了就立即进行持久化的操作，而是在 seq_no 增加到一定的阈值时才触发。  
  
比如我们设定阈值为 200，步长为 100，此时用户的 seq_no 为 55，那么用户需要一直更新 seq_no 到 200 才会触发持久化的操作，然后阈值更新成 300。而如果此时系统异常或者其他原因重启，则 seq_no 直接变更为 200，阈值变更为300。在这个过程中，阈值跟步长都是需要持久化存储的。当然对于每个用户来讲，阈值跟步长可以不同。  
  
还是刚刚的例子  
   
![seq2](https://wx4.sinaimg.cn/mw1024/9a30a1bagy1g3f62za8bbj20sg0lc404.jpg)  
  
1. 内存中保存当前 seq_no：cur_seq，阈值：max_seq，步长：step  
2. 更新 seq_no 时，将cur_seq++，同时与max_seq比较：如果cur_seq > max_seq，将 max_seq += step，并持久化max_seq  
3. 重启时，读出持久化的max_seq，赋值给cur_seq    
    
这样通过步进式的设计，在保证 seq_no 不回退的前提下，可以大幅地提升 IO 性能。这里还会有一个容易被忽视的问题，就是如果机器重启时，需要一次性加载所有的 max_seq 到内存中，按现在这种每个账号对应一个单独的 max_seq 的设计，就需要一定的耗时进行加载，如果数据不是本地存放的话，加载需要消耗网络传输，这样会造成更大的延迟。  
  

![seq3](https://wx2.sinaimg.cn/mw1024/9a30a1bagy1g3f62zehegj20sg0lcaco.jpg)  
  
因为分布式的环境中通常都会考虑到分 set，这样对于不同 set 中的不同机器来讲，可以将路由到同一台机器上的所有账号，或者一部分账号统一使用一个 max_seq，这样可以大幅减少 max_seq 数据量的大小，以此来减小机器重启需要加载 max_seq 的时间。  
  
### sequence 的架构及容灾  
  
[这篇文章](https://www.infoq.cn/article/wechat-serial-number-generator-architecture)是微信官方公布的 sequence 的架构及容灾设计，可以从中看到一些后台设计的哲学，以及随着时间发展，微信架构设计的变与不变。  
  
好的设计总是简洁的。
好的方案总是优雅的。

  

  
  
  
  
  
  
  
  
  
  
---
  By 唐瑞甫  
  2019-05-26

