---
layout:     post
title:      关于微信红包的一点思考(一) 
subtitle:   见证奇迹的时刻
date:       2019-04-14
author:     唐瑞甫
header-img: img/post-bg-coffee.jpeg
catalog: true
tags: 
    - 分布式

---  

最重要的事情放在最前面。  
  
到目前为止，微信尚未公布其红包算法的任何实现，本文仅仅只是个人的一些思考，实际实现方式可能与本文中的实现有较大出入。
  
  

#### Algorithm  
  
对微信红包来讲，**算法可能是最简单的，也可能是最复杂的**。 
  
单从算法实现的角度，微信红包的实现只需要满足以下几个条件：  
  
1. 每个红包的金额是随机的。  
2. 每个红包的金额最少为0.01(单位默认为RMB)  
3. 抢到的红包个数一定等于发红包的个数(默认抢红包的人更多)  
  
从随机的角度来看，并非是完全随机的。比如 10 个人抢 100 个红包，如果是完全随机的情况，则第一个人是有可能抢到 99元 以上的金额的，但是实际并不会发生这种情况。而且，每次抢红包实际上是依赖前面抢红包的结果的，因为**期望值会变**。这样看来，全随机就不会是一个好的选择。   
  
一个**可行的方案**是跟随着期望值的变化而对随机的范围进行动态的限定。把每次产生随机数的范围限制在 **[0.01, 期望值 * 2]** 这个范围。还是刚刚那个例子，10 个人抢 100 元红包。那么第一次的范围在 [0.01, 100/10 * 2] 这个区间内，这样既保证了随机性，又不会对后面的结果产生影响。而且，在这个范围随机，每次用户抢到红包的金额低于期望值的概率跟高于期望值的概率理论上都是 50%。既然是“团队游戏”，公平的体验还是蛮重要的。  
  
即便是缩小了随机的范围，依然可能出现最后一个用户抢到的红包为 0 甚至为负数的情况，以 5 个人抢 50 元红包举例，如果每次用户都能抢到期望值的两倍则会出现这种情况：    
20，15，10，5，0  
最后一个红包金额为 0，解决方案其实很简单，**只要保证最后剩下的用户金额为 0.01** 就够了。  
  
算法的实现如下，单纯考虑算法实现起来确实比较简单  
  
```
double getRedPackage(double remainMoney, int remainSize) {
    // remainSize 剩余的红包数量
    // remainMoney 剩余的钱
    if (remainSize == 1) {
        remainSize--;
        return round(remainMoney * 100) / 100;
    }
    double min   = 0.01; //最小金额
    double max   = remainMoney / remainSize * 2; //两倍期望
    double money = (rand() / double(RAND_MAX)) * max;
    money = money < min ? 0.01: money;
    money = floor(money * 100) / 100;
    remainSize--;
    remainMoney -= money;
    return money;
}  

```
  
  
#### Design
  
说算法简单是因为抛开其他因素，单纯实现红包分配算法，的确不难。但如果考虑到过年这种场景，超海量高并发 + 金融交易，情况就会变得相当复杂。  
  
首先，抢红包这个过程其实被分成了两步，抢红包 跟 拆红包。这里就会涉及到两个问题：  
  
1. 为什么要涉及到两步，只有一步不是更好吗？  
2. 分成了两步，是不是可以不用实时计算，预计算预存储是否效率更高？  
  
这里说下我个人的理解，有不对的地方，随时欢迎批评指正。  
  
对于第一点，两步涉及有点**类似于读写分离**。考虑一个很简单的场景，微信群现在一共 200 人，现在发了一个个数为 50 的红包。这时，如果抢红包只有一步的话，200 个人同事抢，就会有 200 个请求到达下一层，触发计算逻辑，然后最早的 50 个请求获得相应红包金额，另外 150 个被告知未抢到红包。这时对于真正的计算逻辑来讲，只会有 50 个请求是有效的(能够抢到红包)，其余的请求都是无效的，但还是会触发计算逻辑，消耗CPU。而海量分布式的场景中，同一时刻红包的量无疑是巨大的，大量对资源无谓的消耗显然是不合理的。  
  
而如果设计成两步的流程，虽然从用户体验上来讲，多了一次点击的操作，但是可以有效的过滤到绝大部分无效的请求，真正能够触发到后端计算逻辑的几乎都是有效请求。这样对于整个设计流程来讲，更为有效合理。当然，从产品设计的角度来讲，抢完之后多一次拆的过程，也更能体验游戏的趣味性跟刺激性。  
  
对于第二点，从设计的角度来讲，无疑是**实时计算效率更高**。如果在发红包以后就进行预计算，那么就需要将计算结果进行预存储，这时几乎只能将结果存储在内存中。如果将计算结果存在 Redis 这种 cache 层里，在海量高并发这种场景中几乎一定会出现读写错误，无论是出现读或者写失败的情况，都是很难处理的。而如果将所有的计算结果存储在内存中，无疑是一笔巨大的开销。  
  
如果是实时计算，则对于内存几乎没有太多额外的压力，压力主要来自 CPU。但是考虑到每次计算的金额其实都很小，而且从算法实现来讲，计算产生的时间复杂度并不高，**实时计算也不会造成过多的时延**。以目前生产环境物理机器的配置来讲，这个计算量并不会带来太多 CPU 的消耗，更不会产生无法接受的计算时延。  
  
#### Next  
  
原本计划是一篇文章写完的，然后发现内容确实有点多，而且以文字内容居多，全部放在一篇体验不太好，所以最后决定分为上下两篇，这部分主要是自己关于算法跟流程设计的一些思考，而下部分则是关于架构设计的一些思考。比如这部分里谈到了抢不到抢跟拆的设计，即使分开为两步，也仍然会出现很多时候抢到了红包但是拆开却没有的情况，为什么还是会有无效的请求能到后端呢？欢迎跟我一起讨论一起进步。  
  
最后，重中之重，**金融无小事，凡事需谨慎**。
  
  
---
  By 唐瑞甫  
  2019-04-14

