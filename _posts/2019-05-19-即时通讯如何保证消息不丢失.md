---
layout:     post
title:      IM服务如何保证消息不丢失(上)
subtitle:   微信是如何保证的
date:       2019-05-19
author:     唐瑞甫
header-img: img/post-bg-coffee.jpeg
catalog: true
tags: 
    - 分布式

---  

就在今天(5月15日)，腾讯刚刚公布了 2019 年 Q1 的财报，其中微信的 MAU(月活跃用户数) 超过了 11 亿，相比去年同期增加接近 7% 。作为一款超级 APP，在如此大的用户量的基础之上还能保持如何增速，实属不易。  
  
就在微信已经渗透到生活的方方面面时，作为一名互联网从业者，依旧对于微信这款 APP 保持着强烈的好奇。『微信，是一个生活方式。』而生活方式的核心，依然是 IM 服务。对于即时通讯来讲，对于消息的收发会有两点基本要求：  
  
1. 消息尽可能实时送达  
2. 不丢消息  
  
注意，第 1 点是没法完全保证的，如果网络环境特别差的情况下是没法保证实时的，所以是**尽可能**的保证。而第 2 点，则可以做到不丢消息。
  


### msg 的收发流程  
  
#### 发送 msg  
  
发送 msg 的流程如下所示  
  
![发送msg](https://wx3.sinaimg.cn/mw1024/9a30a1bagy1g36wxkwfahj20sg0lcta5.jpg)  
  
可以看到整个过程可以分为两个阶段：  
  
1. 手机 A 发送 msg 到服务器，对应于上图中的 1，2，3 阶段。  
2. 服务器向手机 B 发送通知，对应于上图中的 4，5 阶段。  
  
对于第 2 步向手机 B 发送通知的过程，逻辑层服务器也会推送一条 push tips 给手机 B 操作系统自带的 Push 系统，这里为了简化流程就省略掉了。
  
#### 获取 msg  
  
对应的获取 msg 的流程如下所示：  
  
![获取msg](https://wx2.sinaimg.cn/mw1024/9a30a1bagy1g36wxkwayhj20sg0lc0tw.jpg)  
  
手机 B 主动向服务器发送请求去获取 msg 。  
  
### sequence 的诞生  
  
那么在 msg 收发的过程中，如何确保 msg 不发生丢失呢？  
  
简单粗暴的做法是对收到的每条 msg 都进行一次ack确认，但该方案在手机端和服务器之间的交互过多，系统很容易就达到瓶颈状态，并且也会遇到在网络不佳的情况下ack丢失等问题。  
  
**为了完美的做到 msg 不丢**，进而引入了 sequence 机制。  
  
#### sequence 是什么  
  
sequence 表示数据版本号，本质上是一个整数，具有如下两个性质：  
  
1. 32位**递增连续**整数  
2. 每个用户都有自己**独立**的32位空间  
  
结合到上文中的 msg 的收发流程，则需要在手机端跟服务器端做出如下几点约定：  
  
1. 每个用户的每条 msg 都需要分配一个 seq_no  
2. 服务器存储每个用户已经分配到的最大 seq_no  
3. 手机端存储有已收取 msg 的最大 seq_no  
  
#### 引入 sequence 的收发流程  
  
引入了 sequence 的流程图如下  
  
![sequence流程](https://wx2.sinaimg.cn/mw1024/9a30a1bagy1g36wxkxbusj20sg0lcgnj.jpg)
  
可以看到根据服务器和手机端之间 seq_no 的差异，可以很轻松的实现增量下发手机端未
收取的 msg 。即使在网络环境较差的情况下，发生丢包导致服务器的回包不能到达手机端。由于手机端只会在确认收取到 msg 后才会更新本地的 seq_no，所以**即使回包丢了，手机端等待超时后重新拿旧的 seq_no 去服务器获取 msg，同样可以正确的获取未下发的 msg **。  
  
#### 几个例子  
  
![1](https://wx3.sinaimg.cn/mw1024/9a30a1bagy1g36wxkwe6rj20sg0lcq3v.jpg)  
  
假设手机端此时拿 cli_seq = 100 去服务器获取 msg，此时服务器 svr_seq = 200，那手机端可以将 seq_no 为(100, 200] 的msg 获取到，同时更新本地的 cli_seq = 200   
  
![2](https://wx4.sinaimg.cn/mw1024/9a30a1bagy1g36wxkxcsvj20sg0lcjsr.jpg) 
  
由于手机端存储的 seq_no 是确认收到 msg 的最大 seq_no，所以**手机端每次到服务器来收取 msg 也可以认为是对上一次收取 msg 的确认**。  
  
同一个帐号在多个手机端轮流登录的情况下，只要服务器存储手机端已确认的 seq_no，那就可以简单的实现**已确认下发的 msg 不会重复下发**，不同手机端之间轮流登录不会收到重复的 msg。  
    
![3](https://wx3.sinaimg.cn/mw1024/9a30a1bagy1g36wxkxra0j20sg0lc401.jpg)   
  
此时用另外一台手机登录，并且在手机上的 cli_seq = 140。由于服务器已经确认 seq_no <= 200 的 msg 已经被确认获取，则不会再返回 seq_no 为 (140, 200] 的 msg，而是将seq_no 为 (200, 260]的 msg 下发给手机端。  
  
这里 (200, 260] 的 msg 有可能是两台手机都收取到，但是 seq_no 为 (200, 260] 的 msg 时服务器没有得到手机端的确认，所以为了防止 msg 丢失，seq_no 为 (200, 260] 的 msg 也是需要下发给另一台手机的。  
  
### 小结  
  
这篇文章主要对于消息收发中的 sequence 机制做了一些介绍，可以看到这套方案的简洁与优雅。实际在大规模分布式场景中，如何将这个机制进行落地，还有很大的学问值得研究。  
  
下篇文章从架构设计的角度一起去看下海量分布式场景中如何实施这套 sequence 机制。

  

  
  
  
  
  
  
  
  
  
  
---
  By 唐瑞甫  
  2019-05-19

